#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import json
import time
import threading
from typing import Dict, Tuple

from flask import Response, request
import sqlalchemy
import gevent

from vulcanus.log.log import LOGGER
from vulcanus.multi_thread_handler import MultiThreadHandler
from vulcanus.restful.resp import state
from vulcanus.restful.response import BaseResponse
from zeus.conf import configuration
from zeus.conf.constant import CERES_CVE_FIX, CERES_CVE_REPO_SET, CERES_CVE_ROLLBACK, CERES_CVE_SCAN, CveTaskStatus
from zeus.database.proxy.host import HostProxy
from zeus.database.table import Host
from zeus.function.model import ClientConnectArgs
from zeus.function.verify.vulnerability import CveFixSchema, CveRollbackSchema, CveScanSchema, RepoSetSchema
from zeus.host_manager.ssh import execute_command_and_parse_its_result


def query_host_basic_info(host_list: list, username: str) -> Tuple[str, Dict]:
    """
    Query host info from database by host id

    Args:
        host_list(list): host id list
        username(str): username

    Returns:
        str: status code
        dict: e.g
            {
                host_id:{
                    "host_id": 1 //host_id,
                    "host_ip": "127.0.0.1",
                    "host_name": "test-1",
                    "ssh_user":"root",
                    "ssh_port": 22,
                    "pkey": "RSA-KEY string",
                }
            }
    """
    try:
        with HostProxy() as proxy:
            status_code, host_infos = proxy.get_host_info({"host_list": host_list, "username": username})
    except sqlalchemy.exc.SQLAlchemyError:
        LOGGER.error("connect to database error")
        return state.DATABASE_CONNECT_ERROR, dict()

    if status_code != state.SUCCEED:
        return status_code, dict()
    result = {}
    for host in host_infos:
        result[host.get("host_id")] = {
            "host_id": host.get("host_id"),
            "host_ip": host.get("host_ip"),
            "host_name": host.get("host_name"),
            "ssh_user": host.get("ssh_user"),
            "ssh_port": host.get("ssh_port"),
            "pkey": host.get("pkey"),
        }
    return state.SUCCEED, result


def generate_tasks(tasks: list, host_infos: dict, **kwargs: dict) -> list:
    """
    Generate parameter groups for multi threading handler

    Args:
        tasks(list): e.g
            [{
                "host_id": "host_id",
            }]
        host_infos(dict): e.g
            {
                "host_id": {
                    "host_id": 1 //host_id,
                    "host_ip": "127.0.0.1",
                    "host_name": "test-1",
                    "ssh_user":"root",
                    "ssh_port": 22,
                    "pkey": "RSA-KEY string",
                }
            }
        **kwargs(dict): other task info

    Returns:
        list: e.g
            [(host_info_1,task_info),(host_info_2,task_info),...]
    """
    new_tasks = []
    for task in tasks:
        if task.get("host_id") in host_infos:
            task.update(kwargs)
            new_tasks.append((host_infos.get(task.get('host_id')), task))
    return new_tasks


class BaseExcuteTask:
    def __init__(self) -> None:
        self._header = {'content-type': 'application/json', 'access_token': request.headers.get('access_token')}


class ExecuteRepoSetTask(BaseResponse, BaseExcuteTask):
    """
    Interface for repo set.
    Restful API: post
    """

    def _execute_task(self, host_info: dict) -> dict:
        """
        Execute repo set task and return its result

        Args:
            host_info(dict): e.g
                {
                    "host_id": "host_id",
                    "host_ip": "host_ip",
                    "ssh_port": 22,
                    "ssh_user": "ssh_user",
                    "pkey": "rsa-key-string",
                }

        Returns:
            None
        """
        request_body = {
            "execution_time": int(time.time()),
            "task_id": self._task_id,
            "host_id": host_info.get("host_id"),
            "host_ip": host_info.get("host_ip"),
            "host_name": host_info.get("host_name"),
            "repo_name": self.repo_info.get("name"),
        }

        command_args = {
            "repo_info": self.repo_info,
            "check_items": self._check_items,
        }
        command = CERES_CVE_REPO_SET % json.dumps(command_args)
        status, repo_set_result = execute_command_and_parse_its_result(
            ClientConnectArgs(
                host_info.get("host_ip"),
                host_info.get("ssh_port"),
                host_info.get("ssh_user"),
                host_info.get("pkey"),
                60 * 10,
            ),
            command,
        )
        if status != state.SUCCEED:
            request_body.update({"status": CveTaskStatus.FAIL, "log": repo_set_result})
        else:
            repo_set_result_dict = json.loads(repo_set_result)
            request_body.update(
                {
                    "status": CveTaskStatus.SUCCEED
                    if repo_set_result_dict.get("code") == state.SUCCEED
                    else CveTaskStatus.FAIL,
                    "log": repo_set_result_dict.get("msg"),
                }
            )

        url = f'http://{configuration.apollo.get("IP")}:{ configuration.apollo.get("PORT")}{self._callback_url}'
        self.get_response("post", url, request_body, self._header, timeout=10)

    @BaseResponse.handle(schema=RepoSetSchema)
    def post(self, **params) -> Response:
        """
        execute repo set task

        Args:
            params (dict): e.g
            {
                "task_id": "task_id_1",
                "task_name":"name",
                "task_type": "repo set",
                "total_hosts": ["host_id1", "host_id2"],
                "check_items": [],
                "repo_info": {
                    "name": "openEuler2203",
                    "dest": "/etc/yum.repos.d/aops-update.repo",
                    "repo_content": "update"
                    },
                "tasks": [
                    {
                        "host_id": "host_id1",
                        "check": false
                    },
                    {
                        "host_id": "host_id2",
                        "check": false
                    }
                ],
                "callback":"/vulnerability/task/callback/repo/set",
                "username": "admin"
            }

        Returns:
            response body
        """
        status_code, host_infos = query_host_basic_info(params.get('total_hosts'), params.get('username'))
        if status_code != state.SUCCEED:
            return self.response(code=status_code)

        self._callback_url = params.get('callback')
        self._header = {'content-type': 'application/json', 'access_token': request.headers.get('access_token')}
        self._task_id = params.get("task_id")
        self._task_name = params.get("task_name")
        self._task_type = params.get("task_type")
        self._check_items = params.get('check_items')
        self.repo_info = params.get('repo_info')
        threading.Thread(
            target=lambda: gevent.joinall([gevent.spawn(self._execute_task, host) for host in host_infos.values()])
        ).start()
        return self.response(code=state.SUCCEED)


class ExecuteCveScanTask(BaseResponse, BaseExcuteTask):
    """
    Interface for cve scan.
    Restful API: POST
    """

    def _execute_task(self, host_info: Host, timeout: float = None) -> None:
        """
        Execute cve scan task and callback its result

        Args:
            "host_info"(dict): e.g
                {
                    "host_id": "host_id",
                    "host_ip": "host_ip",
                    "ssh_port": 22,
                    "ssh_user": "ssh_user",
                    "pkey": "rsa-key-string",
                }
        Returns:
            None
        """
        request_body = {
            "host_id": host_info.get("host_id"),
            "task_id": self._task_id,
            "status": CveTaskStatus.SUCCEED,
        }
        status, cve_scan_result = execute_command_and_parse_its_result(
            ClientConnectArgs(
                host_info.get("host_ip"),
                host_info.get("ssh_port"),
                host_info.get("ssh_user"),
                host_info.get("pkey"),
                timeout,
            ),
            CERES_CVE_SCAN % json.dumps({"check_items": self._check_items}),
        )
        if status != state.SUCCEED:
            request_body["status"] = CveTaskStatus.FAIL
        else:
            request_body.update(json.loads(cve_scan_result))

        self.get_response(
            "post",
            f'http://{configuration.apollo.get("IP")}:{ configuration.apollo.get("PORT")}{self._callback_url}',
            request_body,
            self._header,
            timeout=10,
        )

    @BaseResponse.handle(schema=CveScanSchema)
    def post(self, **params) -> Response:
        """
        execute cve scan task

        Args:
            params (dict): e.g
            {
                "task_id": "task_id_1",
                "task_name":"name",
                "task_type": "cve scan",
                "total_hosts": [1,2],
                "check_items": [],
                "callback":"/vulnerability/task/callback/cve/scan",
                "username": "admin"
            }

        Returns:
            response body
        """
        # Query host basic info from database
        status_code, host_infos = query_host_basic_info(params.get('total_hosts'), params.get('username'))
        if status_code != state.SUCCEED:
            return self.response(code=status_code)
        # parse args
        self._callback_url = params.get('callback')
        if params.get("timed"):
            self._header.update(
                {
                    "exempt_authentication": configuration.individuation.get("EXEMPT_AUTHENTICATION"),
                    "local_account": params.get("username"),
                }
            )
        self._task_id = params.get("task_id")
        self._check_items = params.get('check_items')
        # Execute task
        threading.Thread(
            target=lambda: gevent.joinall([gevent.spawn(self._execute_task, host) for host in host_infos.values()])
        ).start()

        return self.response(code=state.SUCCEED)


class ExecuteCveFixTask(BaseResponse, BaseExcuteTask):
    """
    Interface for cve fix.
    Restful API: POST
    """

    def _execute_task(self, host_info: dict, task_info: dict, timeout: float = None) -> dict:
        """
        Execute cve fix task and callback

        Args:
            "host_info"(dict): e.g
                {
                    "host_id": 1, //host id number
                    "host_ip": "127.0.0.1",
                    "host_name": "test_host",
                    "ssh_port": 22,
                    "ssh_user": "root",
                    "pkey": "RSA-KEY-string",
                }
        Returns:
            None
        """

        def gen_failed_result(cves: dict, log: str):
            result = []
            for cve in cves:
                cve_fix_result = {"cve_id": cve.get("cve_id"), "result": "failed", "rpms": []}
                for rpm in cve.get("rpms"):
                    cve_fix_result["rpms"].append(
                        {"installed_rpm": rpm.get("installed_rpm"), "result": "fail", "log": log}
                    )
                result.append(cve_fix_result)
            return result

        request_body = {
            "execution_time": int(time.time()),
            "host_id": host_info.get("host_id"),
            "task_id": self._task_id,
            "host_ip": host_info.get("host_ip"),
            "host_name": host_info.get("host_name"),
        }

        command = CERES_CVE_FIX % json.dumps(
            {
                "accepted": self._accepted,
                "check_items": self._check_items,
                "cves": task_info.get("cves"),
                "takeover": self._takeover,
            }
        )
        status, cve_fix_result = execute_command_and_parse_its_result(
            ClientConnectArgs(
                host_info.get("host_ip"),
                host_info.get("ssh_port"),
                host_info.get("ssh_user"),
                host_info.get("pkey"),
                60 * 10,
            ),
            command,
        )
        if status != state.SUCCEED:
            request_body["status"] = CveTaskStatus.FAIL
            request_body["cves"] = gen_failed_result(task_info.get("cves"), cve_fix_result)
        else:
            cve_fix_result_json = json.loads(cve_fix_result)
            if cve_fix_result_json.pop("code") != state.SUCCEED:
                request_body["status"] = CveTaskStatus.FAIL

            request_body.update(
                {
                    "status": CveTaskStatus.SUCCEED,
                    "check_items": cve_fix_result_json.get("check_items"),
                    "cves": cve_fix_result_json.get("cves"),
                }
            )
        url = f'http://{configuration.apollo.get("IP")}:{configuration.apollo.get("PORT")}{self._callback_url}'
        self.get_response("post", url, request_body, self._header, timeout=10)

    @BaseResponse.handle(schema=CveFixSchema)
    def post(self, **params) -> Response:
        """
        execute cve fix task

        Args:
            params (dict): e.g
                {
                    "task_id": task_id",
                    "task_name":"task_name",
                    "task_type": "cve fix",
                    "total_hosts": ["host_id"],
                    "check_items": [],
                    "tasks": [
                        {
                            "host_id": "host_id",
                            "check": false,
                            "cves":["CVE-2021-3782","CVE-2021-37822"]
                        }
                    "callback":"/vulnerability/task/callback/cve/fix"
                }
        Returns:
            response body
        """
        status_code, host_infos = query_host_basic_info(params.get('total_hosts'), params.get('username'))
        if status_code != state.SUCCEED:
            return self.response(code=status_code)
        # parse args
        self._callback_url = params.get('callback')
        self._task_id = params.get("task_id")
        self._task_name = params.get("task_name")
        self._task_type = params.get("task_type")
        self._accepted = params.get('accepted')
        self._takeover = params.get('takeover')
        self._check_items = params.get('check_items')
        # Execute task
        threading.Thread(
            target=lambda: gevent.joinall(
                [gevent.spawn(self._execute_task, *task) for task in generate_tasks(params.get('tasks'), host_infos)]
            )
        ).start()
        return self.response(code=state.SUCCEED)


class ExecuteCveRollbackTask(BaseResponse, BaseExcuteTask):
    """
    Interface for cve rollback.
    Restful API: POST
    """

    def _execute_task(self, host_info: dict, task_info: dict) -> dict:
        """
        Execute cve rollback task

        Args:
            "host_info"(dict): e.g
                {
                    "host_id": 1,
                    "host_ip": "127.0.0.1",
                    "host_name": "test_host",
                    "ssh_port": 22,
                    "ssh_user": "root",
                    "pkey": "RSA-KEY-string",
                }
            task_info (dict): e.g
                {
                    "host_id": "id1",
                    "cves": [
                        {
                            "cve_id": "cve1",
                            "hotpatch": true
                        }
                    }
                }
        Returns:
            None
        """

        def gen_fail_result(cves, log):
            result = []
            for cve in cves:
                result.append({"cve_id": cve["cve_id"], "result": "fail", "log": log})

            return result

        request_body = {
            "execution_time": int(time.time()),
            "task_id": self._task_id,
            "host_id": host_info.get("host_id"),
            "host_ip": host_info.get("host_ip"),
            "host_name": host_info.get("host_name"),
        }
        command = CERES_CVE_ROLLBACK % json.dumps(dict(cves=task_info["cves"]))
        status, cve_rollback_result = execute_command_and_parse_its_result(
            ClientConnectArgs(
                host_info['host_ip'], host_info['ssh_port'], host_info['ssh_user'], host_info['pkey'], 60 * 10
            ),
            command,
        )

        if status != state.SUCCEED:
            request_body["status"] = CveTaskStatus.FAIL
            request_body["cves"] = gen_fail_result(task_info.get("cves"), cve_rollback_result)
        else:
            request_body["cves"] = {
                cve["cve_id"]: cve["result"] for cve in json.loads(cve_rollback_result)["rollback_result"]
            }

        apollo_ip = configuration.apollo.get("IP")
        apollo_port = configuration.apollo.get("PORT")
        url = f'http://{apollo_ip}:{apollo_port}{self._callback_url}'
        self.get_response("post", url, request_body, self._header, 10)

    @BaseResponse.handle(schema=CveRollbackSchema)
    def post(self, **params) -> Response:
        """
        Execute cve rollback task

        Args:
            params (dict): e.g
                {
                    "task_id": "2",
                    "task_name": "CVE修复回滚",
                    "task_type": "cve rollback",
                    "total_hosts": ["id1", "id2"],
                    "tasks": [
                                {
                                    "host_id": "id1",
                                    "cves": [
                                        {
                                            "cve_id": "cve1",
                                            "hotpatch": true
                                        }
                                    }
                                },
                            ],
                    "callback": "/vulnerability/task/callback/cve/rollback"
                }
        Returns:
            response body
        """
        status_code, host_infos = query_host_basic_info(params.get('total_hosts'), params.get('username'))
        if status_code != state.SUCCEED:
            return self.response(code=status_code)

        # Generate tasks
        self._callback_url = params.get('callback')
        self._task_id = params.get("task_id")
        self._task_name = params.get("task_name")
        self._task_type = params.get("task_type")

        # execute task
        wait_execute_tasks = [
            gevent.spawn(self._execute_task, *task) for task in generate_tasks(params.get('tasks'), host_infos)
        ]
        threading.Thread(target=lambda: gevent.joinall(wait_execute_tasks)).start()
        return self.response(code=state.SUCCEED)
