#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import json
import time
import threading
from abc import abstractmethod
from typing import Dict, Tuple

from flask import Response, request
import retrying
from retrying import retry
import gevent


from vulcanus.exceptions import DatabaseConnectionFailed
from vulcanus.log.log import LOGGER
from vulcanus.restful.resp import state
from vulcanus.restful.response import BaseResponse
from zeus.conf import configuration
from zeus.conf.constant import (
    CERES_CVE_FIX,
    CERES_CVE_REPO_SET,
    CERES_CVE_ROLLBACK,
    CERES_HOTPATCH_REMOVE,
    CERES_CVE_SCAN,
    CveTaskStatus,
    VUL_TASK_CVE_SCAN_NOTICE,
)
from zeus.database.proxy.host import HostProxy
from zeus.database.table import Host
from zeus.function.model import ClientConnectArgs
from zeus.function.verify.vulnerability import (
    CveFixSchema,
    CveRollbackSchema,
    CveScanSchema,
    HotpatchRemoveSchema,
    RepoSetSchema,
)
from zeus.host_manager.ssh import execute_command_and_parse_its_result


def query_host_basic_info(host_list: list, username: str) -> Tuple[str, Dict]:
    """
    Query host info from database by host id

    Args:
        host_list(list): host id list
        username(str): username

    Returns:
        str: status code
        dict: e.g
            {
                host_id:{
                    "host_id": 1 //host_id,
                    "host_ip": "127.0.0.1",
                    "host_name": "test-1",
                    "ssh_user":"root",
                    "ssh_port": 22,
                    "pkey": "RSA-KEY string",
                }
            }
    """
    try:
        with HostProxy() as proxy:
            status_code, host_infos = proxy.get_host_info({"host_list": host_list, "username": username})
    except DatabaseConnectionFailed:
        LOGGER.error("Connect to database error")
        return state.DATABASE_CONNECT_ERROR, dict()

    if status_code != state.SUCCEED:
        return status_code, dict()
    result = {}
    for host in host_infos:
        result[host.get("host_id")] = {
            "host_id": host.get("host_id"),
            "host_ip": host.get("host_ip"),
            "host_name": host.get("host_name"),
            "ssh_user": host.get("ssh_user"),
            "ssh_port": host.get("ssh_port"),
            "pkey": host.get("pkey"),
        }
    return state.SUCCEED, result


def generate_tasks(tasks: list, host_infos: dict, **kwargs: dict) -> list:
    """
    Generate parameter groups for multi threading handler

    Args:
        tasks(list): e.g
            [{
                "host_id": "host_id",
            }]
        host_infos(dict): e.g
            {
                "host_id": {
                    "host_id": 1 //host_id,
                    "host_ip": "127.0.0.1",
                    "host_name": "test-1",
                    "ssh_user":"root",
                    "ssh_port": 22,
                    "pkey": "RSA-KEY string",
                }
            }
        **kwargs(dict): other task info

    Returns:
        list: e.g
            [(host_info_1,task_info),(host_info_2,task_info),...]
    """
    new_tasks = []
    for task in tasks:
        if task.get("host_id") in host_infos:
            task.update(kwargs)
            new_tasks.append((host_infos.get(task.get('host_id')), task))
    return new_tasks


class BaseExcuteTask(BaseResponse):
    def __init__(self) -> None:
        self._header = {"exempt_authentication": configuration.individuation.get("EXEMPT_AUTHENTICATION")}
        self._callback_url = None
        self._task_id = None

    @property
    def _apollo_service(self):
        return f'http://{configuration.apollo.get("IP")}:{ configuration.apollo.get("PORT")}'

    def _callback(self, body, callback_url):
        @retry(retry_on_result=lambda result: result != state.SUCCEED, stop_max_attempt_number=3, wait_fixed=2000)
        def _response(body, url):
            response = self.get_response(method="post", url=url, data=body, header=self._header)
            return response["label"]

        try:
            url = f'{self._apollo_service}{callback_url}'
            _response(body=body, url=url)
        except retrying.RetryError:
            LOGGER.error(f"Callback failed max retries: {url}")

    @abstractmethod
    def _gen_fail_log(self, body, message=None, **kwargs):
        body["status"] = CveTaskStatus.UNKNOWN if "status" in kwargs else CveTaskStatus.FAIL
        return body

    def _gen_success_log(self, body, result):
        body.update(json.loads(result))
        return body

    def _request_body(self, host_info: dict) -> dict:
        request_body = {
            "execution_time": int(time.time()),
            "task_id": self._task_id,
            "host_id": host_info.get("host_id"),
            "host_ip": host_info.get("host_ip"),
            "host_name": host_info.get("host_name"),
        }
        return request_body

    def _callback_noexist_host_task(self, host_ids: list, **kwargs):
        host_infos = {host_id: dict(host_id=host_id, host_ip=None, host_name=None) for host_id in host_ids}
        message = "Host does not exist"
        if "tasks" in kwargs:
            params = dict(tasks=kwargs.pop("tasks"), host_infos=host_infos)
            params.update(**kwargs)
            tasks = generate_tasks(**params)
        else:
            tasks = [(host_info, None) for host_info in host_infos.values()]

        for host_info, task in tasks:
            body = self._gen_fail_log(
                body=self._request_body(host_info), message=message, task_info=task, status=CveTaskStatus.UNKNOWN
            )
            self._callback(body, self._callback_url)


class ExecuteRepoSetTask(BaseExcuteTask):
    """
    Interface for repo set.
    Restful API: post
    """

    def _gen_fail_log(self, body, message=None, **kwargs):
        _body = super()._gen_fail_log(body=body, message=message, **kwargs)
        _body.update(
            {
                "log": message,
                "check_items": [
                    {"item": item, "result": _body["status"], "log": message} for item in self._check_items
                ],
            }
        )
        return _body

    def _gen_success_log(self, body, result):
        repo_set_result_dict = json.loads(result)
        body.update(
            {
                "status": (
                    CveTaskStatus.SUCCEED if repo_set_result_dict.get("code") == state.SUCCEED else CveTaskStatus.FAIL
                ),
                "log": repo_set_result_dict.get("msg"),
                "check_items": repo_set_result_dict.get("check_items", []),
            }
        )
        return body

    def _request_body(self, host_info: dict) -> dict:
        request_body = super()._request_body(host_info)
        request_body["repo"] = self.repo_info.get("name")
        return request_body

    def _execute_task(self, host_info: dict) -> dict:
        """
        Execute repo set task and return its result

        Args:
            host_info(dict): e.g
                {
                    "host_id": "host_id",
                    "host_ip": "host_ip",
                    "ssh_port": 22,
                    "ssh_user": "ssh_user",
                    "pkey": "rsa-key-string",
                }

        Returns:
            None
        """
        request_body = self._request_body(host_info)
        command_args = {
            "repo_info": self.repo_info,
            "check_items": self._check_items,
        }
        command = CERES_CVE_REPO_SET % json.dumps(command_args)
        status, repo_set_result = execute_command_and_parse_its_result(
            ClientConnectArgs(
                host_info.get("host_ip"),
                host_info.get("ssh_port"),
                host_info.get("ssh_user"),
                host_info.get("pkey"),
                60 * 10,
            ),
            command,
        )
        request_body = (
            self._gen_fail_log(request_body, repo_set_result)
            if status != state.SUCCEED
            else self._gen_success_log(request_body, repo_set_result)
        )

        self._callback(request_body, self._callback_url)

    @BaseResponse.handle(schema=RepoSetSchema)
    def post(self, **params) -> Response:
        """
        execute repo set task

        Args:
            params (dict): e.g
            {
                "task_id": "task_id_1",
                "task_name":"name",
                "task_type": "repo set",
                "total_hosts": ["host_id1", "host_id2"],
                "check_items": [],
                "repo_info": {
                    "name": "openEuler2203",
                    "dest": "/etc/yum.repos.d/aops-update.repo",
                    "repo_content": "update"
                    },
                "tasks": [
                    {
                        "host_id": "host_id1",
                        "check": false
                    },
                    {
                        "host_id": "host_id2",
                        "check": false
                    }
                ],
                "callback":"/vulnerability/task/callback/repo/set",
                "username": "admin"
            }

        Returns:
            response body
        """
        status_code, host_infos = query_host_basic_info(params.get('total_hosts'), params.get('username'))
        if status_code != state.SUCCEED:
            return self.response(code=status_code)

        self._callback_url = params.get('callback')
        self._header["local_account"] = params.get("username")
        self._task_id = params.get("task_id")
        self._task_name = params.get("task_name")
        self._task_type = params.get("task_type")
        self._check_items = params.get('check_items')
        self.repo_info = params.get('repo_info')
        diff_hosts = list(set(params.get('total_hosts')).difference(set(host_infos.keys())))
        if diff_hosts:
            threading.Thread(target=self._callback_noexist_host_task, kwargs=dict(host_ids=diff_hosts)).start()

        threading.Thread(
            target=lambda: gevent.joinall([gevent.spawn(self._execute_task, host) for host in host_infos.values()])
        ).start()
        return self.response(code=state.SUCCEED)


class ExecuteCveScanTask(BaseExcuteTask):
    """
    Interface for cve scan.
    Restful API: POST
    """

    def _gen_fail_log(self, body, message=None, **kwargs):
        _body = super()._gen_fail_log(body=body, message=message, **kwargs)
        _body["reboot"] = False
        return _body

    def _request_body(self, host_info: dict) -> dict:
        request_body = {
            "host_id": host_info.get("host_id"),
            "task_id": self._task_id,
            "status": CveTaskStatus.SUCCEED,
        }
        return request_body

    def _execute_task(self, host_info: Host, timeout: float = None) -> None:
        """
        Execute cve scan task and callback its result

        Args:
            "host_info"(dict): e.g
                {
                    "host_id": "host_id",
                    "host_ip": "host_ip",
                    "ssh_port": 22,
                    "ssh_user": "ssh_user",
                    "pkey": "rsa-key-string",
                }
        Returns:
            None
        """
        request_body = self._request_body(host_info)
        status, cve_scan_result = execute_command_and_parse_its_result(
            ClientConnectArgs(
                host_info.get("host_ip"),
                host_info.get("ssh_port"),
                host_info.get("ssh_user"),
                host_info.get("pkey"),
                timeout,
            ),
            CERES_CVE_SCAN % json.dumps({"check_items": self._check_items}),
        )
        if status == state.SUCCEED:
            request_body = self._gen_success_log(request_body, cve_scan_result)
        else:
            request_body = self._gen_fail_log(request_body, None)

        self._callback(request_body, self._callback_url)

    @BaseResponse.handle(schema=CveScanSchema)
    def post(self, **params) -> Response:
        """
        execute cve scan task

        Args:
            params (dict): e.g
            {
                "task_id": "task_id_1",
                "task_name":"name",
                "task_type": "cve scan",
                "total_hosts": [1,2],
                "check_items": [],
                "callback":"/vulnerability/task/callback/cve/scan",
                "username": "admin"
            }

        Returns:
            response body
        """

        def execute_task(host_infos, need_to_send_email):
            gevent.joinall([gevent.spawn(self._execute_task, host) for host in host_infos])
            if need_to_send_email:
                LOGGER.info("Plan to request the interface for sending emails")
                # tell apollo to make it send mail
                # you can turn it off by modifying email config configuration in aops-private-config.ini, but it will still be
                # triggered during scheduled cve scan.
                self._callback(body=None, callback_url=VUL_TASK_CVE_SCAN_NOTICE)

        # Query host basic info from database
        status_code, host_infos = query_host_basic_info(params.get('total_hosts'), params.get('username'))
        if status_code != state.SUCCEED:
            return self.response(code=status_code)
        # parse args
        self._callback_url = params.get('callback')
        self._header["local_account"] = params.get("username")
        self._task_id = params.get("task_id")
        self._check_items = params.get('check_items')
        diff_hosts = list(set(params.get('total_hosts')).difference(set(host_infos.keys())))
        if diff_hosts:
            threading.Thread(target=self._callback_noexist_host_task, kwargs=dict(host_ids=diff_hosts)).start()
        # Execute task
        need_to_send_email = request.headers.get("exempt_authentication") or configuration.email.get("ENABLED")
        threading.Thread(target=execute_task, args=(host_infos.values(), need_to_send_email)).start()

        return self.response(code=state.SUCCEED)


class ExecuteCveFixTask(BaseExcuteTask):
    """
    Interface for cve fix.
    Restful API: POST
    """

    def _gen_fail_log(self, body, message=None, **kwargs):
        _body = super()._gen_fail_log(body=body, message=message, **kwargs)
        _body["rpms"] = [
            {"available_rpm": rpm.get("available_rpm"), "result": _body["status"], "log": message}
            for rpm in kwargs["task_info"].get("rpms")
        ]
        return _body

    def _execute_task(self, host_info: dict, task_info: dict, timeout: float = None) -> dict:
        """
        Execute cve fix task and callback

        Args:
            "host_info"(dict): e.g
                {
                    "host_id": 1, //host id number
                    "host_ip": "127.0.0.1",
                    "host_name": "test_host",
                    "ssh_port": 22,
                    "ssh_user": "root",
                    "pkey": "RSA-KEY-string",
                }
        Returns:
            None
        """
        request_body = self._request_body(host_info)
        command = CERES_CVE_FIX % json.dumps(
            {
                "accepted": self._accepted,
                "check_items": self._check_items,
                "fix_type": self._fix_type,
                "rpms": task_info.get("rpms"),
            }
        )
        status, cve_fix_result = execute_command_and_parse_its_result(
            ClientConnectArgs(
                host_info.get("host_ip"),
                host_info.get("ssh_port"),
                host_info.get("ssh_user"),
                host_info.get("pkey"),
                60 * 10,
            ),
            command,
        )

        if status == state.SUCCEED:
            request_body = self._gen_success_log(request_body, cve_fix_result)
        else:
            request_body = self._gen_fail_log(body=request_body, message=cve_fix_result, task_info=task_info)

        self._callback(request_body, self._callback_url)

    @BaseResponse.handle(schema=CveFixSchema)
    def post(self, **params) -> Response:
        """
        execute cve fix task

        Args:
            params (dict): e.g
                {
                    "task_id": task_id",
                    "task_name":"task_name",
                    "task_type": "cve fix",
                    "total_hosts": ["host_id"],
                    "check_items": [],
                    "tasks": [
                        {
                            "host_id": "host_id",
                            "check": false,
                            "cves":["CVE-2021-3782","CVE-2021-37822"]
                        }
                    "callback":"/vulnerability/task/callback/cve/fix"
                }
        Returns:
            response body
        """
        status_code, host_infos = query_host_basic_info(params.get('total_hosts'), params.get('username'))
        if status_code != state.SUCCEED:
            return self.response(code=status_code)
        # parse args
        self._callback_url = params.get('callback')
        self._task_id = params.get("task_id")
        self._task_name = params.get("task_name")
        self._task_type = params.get("task_type")
        self._header["local_account"] = params.get("username")
        self._accepted = params.get('accepted')
        self._fix_type = params.get('fix_type')
        self._check_items = params.get('check_items')
        diff_hosts = list(set(params.get('total_hosts')).difference(set(host_infos.keys())))
        if diff_hosts:
            threading.Thread(
                target=self._callback_noexist_host_task, kwargs=dict(host_ids=diff_hosts, tasks=params.get('tasks'))
            ).start()

        # Execute task
        threading.Thread(
            target=lambda: gevent.joinall(
                [gevent.spawn(self._execute_task, *task) for task in generate_tasks(params.get('tasks'), host_infos)]
            )
        ).start()
        return self.response(code=state.SUCCEED)


class ExecuteHotpatchRemoveTask(BaseExcuteTask):
    """
    Interface for hotpatch remove.
    Restful API: POST
    """

    def _gen_fail_log(self, body, message=None, **kwargs):
        _body = super()._gen_fail_log(body=body, message=message, **kwargs)
        _body["cves"] = [
            {"cve_id": cve, "result": _body["status"], "log": message} for cve in kwargs["task_info"]["cves"]
        ]
        return _body

    def _execute_task(self, host_info: dict, task_info: dict) -> dict:
        """
        Execute hotpatch remove task

        Args:
            "host_info"(dict): e.g
                {
                    "host_id": 1,
                    "host_ip": "127.0.0.1",
                    "host_name": "test_host",
                    "ssh_port": 22,
                    "ssh_user": "root",
                    "pkey": "RSA-KEY-string",
                }
            task_info (dict): e.g
                {
                    "host_id": "id1",
                    "cves": ["CVE-XXXX-XXXX"]
                }
        Returns:
            None
        """
        request_body = self._request_body(host_info)
        command = CERES_HOTPATCH_REMOVE % json.dumps(dict(cves=task_info["cves"]))
        status, hotpatch_remove_result = execute_command_and_parse_its_result(
            ClientConnectArgs(
                host_info['host_ip'], host_info['ssh_port'], host_info['ssh_user'], host_info['pkey'], 60 * 10
            ),
            command,
        )

        if status == state.SUCCEED:
            request_body = self._gen_success_log(request_body, hotpatch_remove_result)
        else:
            request_body = self._gen_fail_log(body=request_body, message=hotpatch_remove_result, task_info=task_info)

        self._callback(request_body, self._callback_url)

    @BaseResponse.handle(schema=HotpatchRemoveSchema)
    def post(self, **params) -> Response:
        """
        Execute hotpatch remove task

        Args:
            params (dict): e.g
                {
                    "task_id": "2",
                    "task_name": "hotpatch remove",
                    "task_type": "hotpatch remove",
                    "total_hosts": ["id1", "id2"],
                    "tasks": [
                                {
                                    "host_id": "id1",
                                    "cves": ["cve-xxxx-xxxx"]
                                },
                            ],
                    "callback": "/vulnerability/task/callback/hotpatch-remove"
                }
        Returns:
            response body
        """
        status_code, host_infos = query_host_basic_info(params.get('total_hosts'), params.get('username'))
        if status_code != state.SUCCEED:
            return self.response(code=status_code)

        # Generate tasks
        self._callback_url = params.get('callback')
        self._task_id = params.get("task_id")
        self._header["local_account"] = params.get("username")
        self._task_name = params.get("task_name")
        self._task_type = params.get("task_type")
        diff_hosts = list(set(params.get('total_hosts')).difference(set(host_infos.keys())))
        if diff_hosts:
            threading.Thread(
                target=self._callback_noexist_host_task, kwargs=dict(host_ids=diff_hosts, tasks=params.get('tasks'))
            ).start()
        # execute task
        wait_execute_tasks = [
            gevent.spawn(self._execute_task, *task) for task in generate_tasks(params.get('tasks'), host_infos)
        ]
        threading.Thread(target=lambda: gevent.joinall(wait_execute_tasks)).start()
        return self.response(code=state.SUCCEED)


class ExecuteCveRollbackTask(BaseExcuteTask):
    """
    Interface for cve rollback.
    Restful API: POST
    """

    def _gen_fail_log(self, body, message=None, **kwargs):
        _body = super()._gen_fail_log(body=body, message=message, **kwargs)
        _body.update(
            {
                "log": message,
                "check_items": [
                    {"item": item, "result": _body["status"]} for item in kwargs["task_info"]["check_items"]
                ],
            }
        )
        return _body

    def _execute_task(self, host_info: dict, task_info: dict) -> None:
        """
        Execute cve rollback task

        Args:
            host_info(dict): e.g
                {
                    "host_id": 1,
                    "host_ip": "127.0.0.1",
                    "host_name": "test_host",
                    "ssh_port": 22,
                    "ssh_user": "root",
                    "pkey": "RSA-KEY-string",
                }
            task_info (dict): e.g
                {
                    "host_id": "id1",
                    "check_items":[],
                    "rollback_type": "hotpatch",
                    "installed_kernel": "kernel-5.1.10",
                    "target_kernel": "kernel-5.1.9",
                    "dnf_event_start": 1,
                    "dnf_event_end": 2,
                }
        Returns:
            None
        """
        request_body = self._request_body(host_info)
        task_info.pop("host_id")
        command = CERES_CVE_ROLLBACK % json.dumps(task_info)
        status, cve_rollback_result = execute_command_and_parse_its_result(
            ClientConnectArgs(
                host_info.get("host_ip"),
                host_info.get("ssh_port"),
                host_info.get("ssh_user"),
                host_info.get("pkey"),
                60 * 10,
            ),
            command,
        )
        if status == state.SUCCEED:
            request_body = self._gen_success_log(request_body, cve_rollback_result)
        else:
            request_body = self._gen_fail_log(body=request_body, message=cve_rollback_result, task_info=task_info)

        self._callback(request_body, self._callback_url)

    @BaseResponse.handle(schema=CveRollbackSchema)
    def post(self, **params) -> Response:
        """
        execute cve rollback task

        Args:
            params (dict): e.g
                {
                    "task_id": "c6714973c9b342a380fd01fdf7f90ef5",
                    "task_name": "cve rollback task",
                    "fix_task_id": "string",
                    "task_type": "cve rollback",
                    "rollback_type": "coldpatch",
                    "check_items": ["network"],
                    "tasks": [
                        {
                            "host_id": 74,
                            "installed_rpm": "kernel-5.1.10",
                            "target_rpm": "kernel-5.1.9",
                            "dnf_event_start": 1,
                            "dnf_event_end": 2
                        }
                    ],
                    "callback": "/vulnerability/task/callback/cve/rollback"
                }
        Returns:
            response body
        """
        total_host = [task_info["host_id"] for task_info in params.get("tasks")]
        status_code, host_infos = query_host_basic_info(total_host, params.get('username'))
        if status_code != state.SUCCEED:
            return self.response(code=status_code)
        # parse args
        self._task_id = params.get("task_id")
        self._task_name = params.get("task_name")
        self._task_type = params.get("task_type")
        self._header["local_account"] = params.get("username")
        self._callback_url = params.get('callback')
        diff_hosts = list(set(total_host).difference(set(host_infos.keys())))
        if diff_hosts:
            threading.Thread(
                target=self._callback_noexist_host_task,
                kwargs=dict(
                    host_ids=diff_hosts,
                    tasks=params.get('tasks'),
                    check_items=params.get('check_items'),
                    rollback_type=params.get('rollback_type'),
                ),
            ).start()
        # Execute task
        tasks = generate_tasks(
            params.get('tasks'),
            host_infos,
            **{
                "check_items": params.get('check_items'),
                "rollback_type": params.get('rollback_type'),
            },
        )
        threading.Thread(
            target=lambda: gevent.joinall([gevent.spawn(self._execute_task, *task) for task in tasks])
        ).start()
        return self.response(code=state.SUCCEED)
