#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import json
from unittest import mock

import sqlalchemy

from vulcanus.restful.resp.state import DATABASE_CONNECT_ERROR, DATABASE_QUERY_ERROR, PARAM_ERROR, SUCCEED, TOKEN_ERROR
from vulcanus.restful.response import BaseResponse
from vulcanus.database.proxy import MysqlProxy
from zeus.conf.constant import EXECUTE_REPO_SET
from zeus.database.proxy.host import HostProxy
from zeus.tests import BaseTestCase
from zeus.vulnerability_manage.view import ExecuteRepoSetTask, query_host_basic_info

client = BaseTestCase.create_app()


class TestRepoSet(BaseTestCase):
    HEADERS = {"Content-Type": "application/json; charset=UTF-8"}
    HEADERS_WITH_TOKEN = {"Content-Type": "application/json; charset=UTF-8", "access_token": "mock_token"}

    MOCK_HOST_INFO = {
        1: {"name": "host_name_1", "ip": "host_ip_1", "address": "host_ip_1:host_port"},
        2: {"name": "host_name_2", "ip": "host_ip_2", "address": "host_ip_2:host_port"},
    }

    def setUp(self) -> None:
        self.MOCK_ARGS = {
            "task_id": "mock_task",
            "task_name": "mock_task_name",
            "task_type": "mock_task_type",
            "total_hosts": [1, 2],
            "check_items": [],
            "repo_info": {"name": "mock_repo_name", "dest": "mock_path", "repo_content": "mock_content"},
            "callback": "/repo-set/callback",
        }

    @mock.patch.object(ExecuteRepoSetTask, "_execute_task")
    @mock.patch('zeus.vulnerability_manage.view.query_host_basic_info')
    @mock.patch.object(MysqlProxy, '_create_session')
    @mock.patch.object(BaseResponse, 'verify_token')
    def test_repo_set_should_return_succeed_when_all_is_right(
        self, mock_verify_token, mock_connect_database, mock_query_host_info, mock_execute_task
    ):
        mock_verify_token.return_value = SUCCEED
        mock_connect_database.return_value = None
        mock_query_host_info.return_value = SUCCEED, self.MOCK_HOST_INFO
        mock_execute_task.return_value = None
        response = client.post(EXECUTE_REPO_SET, data=json.dumps(self.MOCK_ARGS), headers=self.HEADERS_WITH_TOKEN)
        self.assertEqual(SUCCEED, response.json.get('label'))

    @mock.patch.object(BaseResponse, 'verify_token')
    def test_repo_should_return_token_error_when_request_without_token_or_request_with_invalid_token(self, mock_token):
        mock_token.return_value = TOKEN_ERROR
        response = client.post(EXECUTE_REPO_SET, data=json.dumps(self.MOCK_ARGS), headers=self.HEADERS)
        self.assertEqual(TOKEN_ERROR, response.json.get('label'))

    def test_repo_should_return_param_error_when_request_with_incorrect_args(self):
        self.MOCK_ARGS.update({"callback": True})
        response = client.post(EXECUTE_REPO_SET, data=json.dumps(self.MOCK_ARGS), headers=self.HEADERS_WITH_TOKEN)
        self.assertEqual(PARAM_ERROR, response.json.get('label'))

    def test_repo_should_return_400_when_request_without_args(self):
        response = client.post(EXECUTE_REPO_SET, headers=self.HEADERS_WITH_TOKEN)
        self.assertEqual(400, response.status_code)

    def test_repo_should_return_405_when_request_method_is_not_post(self):
        response = client.get(EXECUTE_REPO_SET, data=json.dumps(self.MOCK_ARGS), headers=self.HEADERS_WITH_TOKEN)
        self.assertEqual(405, response.status_code)

    @mock.patch.object(MysqlProxy, '_create_session')
    @mock.patch.object(BaseResponse, 'verify_request')
    def test_repo_set_should_return_database_connect_error_when_cannot_connect_database(
        self, mock_verify_request, mock_connect_database
    ):
        mock_verify_request.return_value = self.MOCK_ARGS, SUCCEED
        mock_connect_database.side_effect = sqlalchemy.exc.SQLAlchemyError("failed to connect database")
        response = client.post(EXECUTE_REPO_SET, data=json.dumps(self.MOCK_ARGS), headers=self.HEADERS_WITH_TOKEN)
        self.assertEqual(DATABASE_CONNECT_ERROR, response.json.get('label'))

    @mock.patch('zeus.vulnerability_manage.view.query_host_basic_info')
    @mock.patch.object(HostProxy, '_create_session')
    @mock.patch.object(BaseResponse, 'verify_token')
    def test_repo_set_should_return_database_query_error_when_query_data_is_error(
        self, mock_verify_request, mock_connect_database, mock_query_host_info
    ):
        mock_verify_request.return_value = SUCCEED
        mock_connect_database.return_value = None
        mock_query_host_info.return_value = DATABASE_QUERY_ERROR, {}
        response = client.post(EXECUTE_REPO_SET, data=json.dumps(self.MOCK_ARGS), headers=self.HEADERS_WITH_TOKEN)
        self.assertEqual(DATABASE_QUERY_ERROR, response.json.get('label'))

    @mock.patch.object(HostProxy, "__exit__")
    @mock.patch.object(HostProxy, "get_host_info")
    @mock.patch.object(HostProxy, "_create_session")
    def test_query_host_basic_info_should_return_host_info_when_query_succeed(
        self, mock_connect, mock_query_host_info, mock_close
    ):
        mock_connect.return_value = None
        mock_close.return_value = None
        mock_query_host_info.return_value = SUCCEED, [
            {
                "host_id": 1,
                "host_ip": "mock_ip",
                "ssh_port": 23,
                "ssh_user": "user",
                "pkey": "pkey",
                "host_name": "test1",
                "host_group_name": "group1",
                "management": True,
                "username": "mock_user",
            }
        ]
        expect_result = {
            1: {
                "host_id": 1,
                "host_ip": "mock_ip",
                "host_name": "test1",
                "ssh_user": "user",
                "ssh_port": 23,
                "pkey": "pkey",
            }
        }
        status, result = query_host_basic_info([1], "mock_user")
        self.assertEqual(SUCCEED, status)
        self.assertEqual(expect_result, result)

    @mock.patch.object(HostProxy, "_create_session")
    def test_query_host_basic_info_should_return_database_connect_error_when_connect_database_error(self, mock_connect):
        mock_connect.side_effect = sqlalchemy.exc.SQLAlchemyError("Connection error")
        status, result = query_host_basic_info([1], "mock_user")
        self.assertEqual(DATABASE_CONNECT_ERROR, status)

    @mock.patch.object(HostProxy, "__exit__")
    @mock.patch.object(HostProxy, "get_host_info")
    @mock.patch.object(HostProxy, "_create_session")
    def test_query_host_basic_info_should_return_database_query_error_when_query_host_info_failed(
        self, mock_connect, mock_query, mock_close
    ):
        mock_connect.return_value = None
        mock_close.return_value = None
        mock_query.return_value = DATABASE_QUERY_ERROR, []
        status, result = query_host_basic_info([1], "mock_user")
        self.assertEqual(DATABASE_QUERY_ERROR, status)
